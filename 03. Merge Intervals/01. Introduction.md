<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Merge Intervals](#merge-intervals)
- [ğŸ”€ Merge Intervals Pattern - Complete Interview Guide](#-merge-intervals-pattern---complete-interview-guide)
  - [ğŸ“‹ Pattern Overview](#-pattern-overview)
    - [ğŸ¯ Core Concept](#-core-concept)
  - [ğŸ” Detecting Overlapping Intervals](#-detecting-overlapping-intervals)
    - [ğŸ“Š Visual ASCII Diagram](#-visual-ascii-diagram)
  - [ğŸ› ï¸ Standard Algorithm Template](#-standard-algorithm-template)
  - [ğŸš€ Common Interview Problem Types](#-common-interview-problem-types)
    - [1ï¸âƒ£ **Basic Merge Intervals** (LC 56)](#-basic-merge-intervals-lc-56)
    - [2ï¸âƒ£ **Insert Interval** (LC 57)](#-insert-interval-lc-57)
    - [3ï¸âƒ£ **Meeting Rooms** (LC 252/253)](#-meeting-rooms-lc-252253)
    - [4ï¸âƒ£ **Interval Intersections** (LC 986)](#-interval-intersections-lc-986)
    - [5ï¸âƒ£ **Employee Free Time** (LC 759)](#-employee-free-time-lc-759)
  - [ğŸ¨ Advanced Techniques](#-advanced-techniques)
    - [ğŸ”„ **Sweep Line Algorithm**](#-sweep-line-algorithm)
      - [ğŸ”¬ **Detailed Sweep Line Breakdown**](#-detailed-sweep-line-breakdown)
      - [ğŸ“Š **Sweep Line Visual Example**](#-sweep-line-visual-example)
      - [ğŸ’» **Complete Sweep Line Coding Examples**](#-complete-sweep-line-coding-examples)
      - [ğŸ¯ **Sweep Line Problem Examples**](#-sweep-line-problem-examples)
    - [ğŸ“š **Two-Pointer Technique**](#-two-pointer-technique)
      - [ğŸ¯ **Detailed Two-Pointer Implementation**](#-detailed-two-pointer-implementation)
      - [ğŸ“ˆ **Two-Pointer Visual Walkthrough**](#-two-pointer-visual-walkthrough)
      - [ğŸ”€ **Interval Intersection Two-Pointer**](#-interval-intersection-two-pointer)
      - [ğŸ’» **Complete Two-Pointer Coding Examples**](#-complete-two-pointer-coding-examples)
      - [ğŸ¯ **Two-Pointer Problem Examples**](#-two-pointer-problem-examples)
    - [ğŸ”ï¸ **Priority Queue/Heap**](#-priority-queueheap)
      - [ğŸ—ï¸ **Detailed Heap Implementation**](#-detailed-heap-implementation)
      - [ğŸ“š **Employee Free Time with K-Way Merge**](#-employee-free-time-with-k-way-merge)
      - [ğŸ¯ **Heap Visual Example**](#-heap-visual-example)
      - [ğŸ’» **Complete Heap Coding Examples**](#-complete-heap-coding-examples)
      - [ğŸ¯ **Priority Queue/Heap Problem Examples**](#-priority-queueheap-problem-examples)
  - [ğŸ“Š **Comprehensive Approach Comparison Table**](#-comprehensive-approach-comparison-table)
    - [ğŸ¯ **Problem-to-Approach Mapping**](#-problem-to-approach-mapping)
    - [ğŸš€ **Performance Characteristics**](#-performance-characteristics)
    - [ğŸ’¡ **Complexity Deep Dive**](#-complexity-deep-dive)
    - [ğŸ¯ **Selection Decision Tree**](#-selection-decision-tree)
  - [ğŸš¨ **Common Pitfalls: Meeting Rooms II Analysis**](#-common-pitfalls-meeting-rooms-ii-analysis)
    - [âŒ **Why This Code is WRONG**](#-why-this-code-is-wrong)
    - [ğŸ” **Critical Bugs Breakdown**](#-critical-bugs-breakdown)
      - [**ğŸš¨ Bug 1: Fundamental Misunderstanding**](#-bug-1-fundamental-misunderstanding)
      - [**ğŸš¨ Bug 2: Wrong Overlap Detection**](#-bug-2-wrong-overlap-detection)
      - [**ğŸš¨ Bug 3: Incorrect Merge Logic**](#-bug-3-incorrect-merge-logic)
      - [**ğŸš¨ Bug 4: Resetting Counter Prematurely**](#-bug-4-resetting-counter-prematurely)
    - [ğŸ“Š **Execution Trace Example**](#-execution-trace-example)
    - [âœ… **Correct Solutions Comparison**](#-correct-solutions-comparison)
    - [ğŸ§  **Key Takeaway for Interviews**](#-key-takeaway-for-interviews)
  - [ğŸ’¡ Interview Success Tips](#-interview-success-tips)
    - [ğŸ¯ **Problem Recognition Signals**](#-problem-recognition-signals)
    - [âš¡ **Optimization Strategies**](#-optimization-strategies)
    - [ğŸš¨ **Common Edge Cases**](#-common-edge-cases)
    - [ğŸ›¡ï¸ **Debug Checklist**](#-debug-checklist)
  - [ğŸª **ASCII Problem Solving Flow**](#-ascii-problem-solving-flow)
  - [ğŸ† **Master Problem Set**](#-master-problem-set)
  - [ğŸ§  **Memory Aids**](#-memory-aids)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Merge Intervals

<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# ğŸ”€ Merge Intervals Pattern - Complete Interview Guide

## ğŸ“‹ Pattern Overview
![alt text](./Images/image.png)

The **Merge Intervals** pattern is a fundamental technique for handling **overlapping time ranges** in coding interviews. Each interval is represented as `[start, end]`, and the goal is to identify overlaps and consolidate them efficiently.

### ğŸ¯ Core Concept

- **Input**: Collection of intervals that may or may not overlap
- **Process**: Sort by start time, then merge overlapping intervals
- **Output**: Consolidated list with no overlaps


## ğŸ” Detecting Overlapping Intervals

Two intervals `[a,b]` and `[c,d]` overlap **if and only if**:

```
a â‰¤ d AND c â‰¤ b
```


### ğŸ“Š Visual ASCII Diagram

```
âœ… OVERLAPPING:
[a----b]
    [c----d]
a â‰¤ d âœ“ AND c â‰¤ b âœ“

âŒ NON-OVERLAPPING:
[a----b]        [c----d]
a > d âœ— OR c > b âœ—

ğŸ”„ TOUCHING (Edge Case):
[a----b][c----d]  
b = c (considered overlapping in most problems)
```


## ğŸ› ï¸ Standard Algorithm Template

```python
def merge_intervals(intervals):
    if not intervals:
        return []
    
    # 1ï¸âƒ£ Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # 2ï¸âƒ£ Initialize result with first interval
    merged = [intervals[0]]
    
    # 3ï¸âƒ£ Process remaining intervals
    for current in intervals[1:]:
        last = merged[-1]
        
        # 4ï¸âƒ£ Check for overlap
        if current[0] <= last[1]:  # Overlap detected
            # Merge by extending end time
            merged[1][1] = max(last[1], current[1])
        else:
            # No overlap - add as new interval
            merged.append(current)
    
    return merged
```


## ğŸš€ Common Interview Problem Types

### 1ï¸âƒ£ **Basic Merge Intervals** (LC 56)

- Merge all overlapping intervals
- **Time**: O(n log n), **Space**: O(1)


### 2ï¸âƒ£ **Insert Interval** (LC 57)

- Insert new interval into sorted list
- **Key insight**: Split into 3 phases (before, overlapping, after)


### 3ï¸âƒ£ **Meeting Rooms** (LC 252/253)

- Determine if all meetings can fit in one room
- Find minimum rooms needed
- **Technique**: Two-pointer or heap approach


### 4ï¸âƒ£ **Interval Intersections** (LC 986)

- Find common time slots between two schedules
- **Technique**: Two-pointer merge


### 5ï¸âƒ£ **Employee Free Time** (LC 759)

- Find gaps when all employees are free
- **Technique**: Merge all busy times, then find gaps


## ğŸ¨ Advanced Techniques

### ğŸ”„ **Sweep Line Algorithm**

Perfect for problems involving **events over time**:

```
ğŸ“… Timeline Visualization:
Events: [(1,+1), (3,-1), (5,+1), (7,-1)]
        â”‚  ğŸ¢   â”‚  ğŸƒ   â”‚  ğŸ¢   â”‚  ğŸƒ
Time:   1      3      5      7
Active: 1      0      1      0
        â””â”€gapâ”€â”€â”€â”€â”€â”˜  â””â”€gapâ”€â”€â”˜
```


#### ğŸ”¬ **Detailed Sweep Line Breakdown**

The **Sweep Line** treats intervals as **discrete events** and processes them chronologically. Each interval `[start, end]` becomes two events: `(start, +1)` and `(end, -1)`.

```python
def sweep_line_intervals(intervals):
    events = []
    
    # ğŸ¯ Convert intervals to events
    for start, end in intervals:
        events.append((start, 1))    # ğŸ“ˆ Activity starts
        events.append((end, -1))     # ğŸ“‰ Activity ends
    
    # ğŸ”„ Sort events (end events before start at same time)
    events.sort(key=lambda x: (x[0], x[1]))
    
    result = []
    active_count = 0
    gap_start = None
    
    # ğŸš¶â€â™‚ï¸ Sweep through timeline
    for time, delta in events:
        # ğŸ”„ State transitions
        if active_count > 0 and active_count + delta == 0:
            gap_start = time  # ğŸ†“ Free time begins
        elif active_count == 0 and active_count + delta > 0:
            if gap_start is not None:
                result.append([gap_start, time])  # ğŸš« Free time ends
        
        active_count += delta
    
    return result
```


#### ğŸ“Š **Sweep Line Visual Example**

```
Input: [[1,3], [4,6], [8,10]]

Events Timeline:
Time:  1    3    4    6    8    10
       +1   -1   +1   -1   +1   -1
Count: 1    0    1    0    1    0
       ğŸ¢   ğŸƒ   ğŸ¢   ğŸƒ   ğŸ¢   ğŸƒ

Gaps Found: [3,4] and [6,8] ğŸ†“
```


#### ğŸ’» **Complete Sweep Line Coding Examples**

**ğŸ¯ Example 1: Meeting Rooms II (LC 253)**

```python
def minMeetingRooms(intervals):
    events = []
    
    # Create start/end events
    for start, end in intervals:
        events.append((start, 1))    # Meeting starts
        events.append((end, -1))     # Meeting ends
    
    # Sort events (end before start at same time)
    events.sort(key=lambda x: (x[0], x[1]))
    
    max_rooms = current_rooms = 0
    
    for time, delta in events:
        current_rooms += delta
        max_rooms = max(max_rooms, current_rooms)
    
    return max_rooms
```

**ğŸ¯ Example 2: Car Pooling (LC 1094)**

```python
def carPooling(trips, capacity):
    events = []
    
    # Create pickup/dropoff events
    for passengers, start, end in trips:
        events.append((start, passengers))    # Pickup
        events.append((end, -passengers))     # Dropoff
    
    events.sort()
    current_passengers = 0
    
    for location, change in events:
        current_passengers += change
        if current_passengers > capacity:
            return False
    
    return True
```

**ğŸ¯ Example 3: My Calendar II (LC 731)**

```python
class MyCalendarTwo:
    def __init__(self):
        self.events = []
    
    def book(self, start, end):
        # Add tentative booking
        temp_events = self.events + [(start, 1), (end, -1)]
        temp_events.sort()
        
        overlap_count = 0
        for time, delta in temp_events:
            overlap_count += delta
            if overlap_count >= 3:  # Triple booking detected
                return False
        
        # Booking successful, add permanently
        self.events.extend([(start, 1), (end, -1)])
        return True
```


#### ğŸ¯ **Sweep Line Problem Examples**

**1ï¸âƒ£ Car Pooling (LC 1094)**

- Determine if car can handle all passenger pickups/dropoffs
- **Key insight**: Convert trips to pickup/dropoff events, track running capacity

**2ï¸âƒ£ My Calendar II (LC 731)**

- Allow booking only if it won't cause triple overlap
- **Key insight**: Track overlap count at each time point using sweep line

**3ï¸âƒ£ The Skyline Problem (LC 218)**

- Find skyline silhouette from building rectangles
- **Key insight**: Process height change events, track max height with heap

**4ï¸âƒ£ Meeting Rooms II (LC 253)**

- Find minimum conference rooms needed
- **Key insight**: Convert meetings to start/end events, track concurrent count


### ğŸ“š **Two-Pointer Technique**

For problems involving **two sorted lists**:

```python
# Meeting Rooms II approach
starts = [1, 2, 3]  ğŸ‘†
ends   = [4, 5, 6]      ğŸ‘†
        rooms++  rooms++  rooms++
```


#### ğŸ¯ **Detailed Two-Pointer Implementation**

The **Two-Pointer** technique is optimal when dealing with **two pre-sorted arrays** or when you need to **track starts and ends separately**.

```python
def meeting_rooms_two_pointer(intervals):
    if not intervals:
        return 0
    
    # ğŸ”„ Separate and sort start/end times
    starts = sorted([interval[0] for interval in intervals])
    ends = sorted([interval[1] for interval in intervals])
    
    start_ptr = end_ptr = 0
    current_rooms = max_rooms = 0
    
    # ğŸš¶â€â™‚ï¸ Walk through both arrays simultaneously
    while start_ptr < len(starts):
        if starts[start_ptr] < ends[end_ptr]:
            # ğŸ¢ Meeting starts - need new room
            current_rooms += 1
            start_ptr += 1
        else:
            # ğŸƒ Meeting ends - free up room
            current_rooms -= 1
            end_ptr += 1
        
        max_rooms = max(max_rooms, current_rooms)
    
    return max_rooms
```


#### ğŸ“ˆ **Two-Pointer Visual Walkthrough**

```
Input: [[0,30], [5,10], [15,20]]

Starts: [0, 5, 15]  ğŸ‘†s
Ends:   [10,20,30]     ğŸ‘†e

Step 1: 0 < 10 â†’ rooms=1, s++
Step 2: 5 < 10 â†’ rooms=2, s++ (max=2) ğŸ¯
Step 3: 15 > 10 â†’ rooms=1, e++
Step 4: Done, max_rooms = 2
```


#### ğŸ”€ **Interval Intersection Two-Pointer**

```python
def interval_intersection(list1, list2):
    result = []
    i = j = 0
    
    while i < len(list1) and j < len(list2):
        # ğŸ” Find intersection boundaries
        start = max(list1[i][0], list2[j][0])
        end = min(list1[i][1], list2[j][1])
        
        # âœ… Valid intersection exists
        if start <= end:
            result.append([start, end])
        
        # ğŸ‘‰ Move pointer of interval that ends earlier
        if list1[i][1] < list2[j][1]:
            i += 1
        else:
            j += 1
    
    return result
```


#### ğŸ’» **Complete Two-Pointer Coding Examples**

**ğŸ¯ Example 1: Interval List Intersections (LC 986)**

```python
def intervalIntersection(firstList, secondList):
    result = []
    i = j = 0
    
    while i < len(firstList) and j < len(secondList):
        # Calculate intersection boundaries
        start = max(firstList[i][0], secondList[j][0])
        end = min(firstList[i][1], secondList[j][1])
        
        # Valid intersection exists
        if start <= end:
            result.append([start, end])
        
        # Move pointer of interval that ends earlier
        if firstList[i][1] < secondList[j][1]:
            i += 1
        else:
            j += 1
    
    return result
```

**ğŸ¯ Example 2: Non-overlapping Intervals (LC 435)**

```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
    
    # Sort by end time for greedy approach
    intervals.sort(key=lambda x: x[1])
    
    count = 0
    end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < end:  # Overlap detected
            count += 1  # Remove current interval
        else:
            end = intervals[i][1]  # Update end time
    
    return count
```

**ğŸ¯ Example 3: Merge Two Sorted Arrays (adapted for intervals)**

```python
def mergeTwoIntervalLists(list1, list2):
    result = []
    i = j = 0
    
    # Merge two sorted lists
    while i < len(list1) and j < len(list2):
        if list1[i][0] <= list2[j][0]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1
    
    # Add remaining intervals
    result.extend(list1[i:])
    result.extend(list2[j:])
    
    # Now merge overlapping intervals
    return merge_intervals(result)
```


#### ğŸ¯ **Two-Pointer Problem Examples**

**1ï¸âƒ£ Interval List Intersections (LC 986)**

- Find overlapping time slots between two schedules
- **Key insight**: Use two pointers to merge sorted lists, calculate intersection boundaries

**2ï¸âƒ£ Non-overlapping Intervals (LC 435)**

- Remove minimum intervals to make rest non-overlapping
- **Key insight**: Sort by end time, use greedy approach with two pointers

**3ï¸âƒ£ Meeting Rooms II (LC 253)**

- Count maximum concurrent meetings
- **Key insight**: Separate start/end times, use two pointers to simulate timeline

**4ï¸âƒ£ Merge Two Sorted Lists (LC 21)**

- Merge two sorted interval lists
- **Key insight**: Standard two-pointer merge with overlap handling


### ğŸ”ï¸ **Priority Queue/Heap**

For **dynamic interval management**:

- Track earliest ending meetings
- Optimal for room allocation problems


#### ğŸ—ï¸ **Detailed Heap Implementation**

**Priority Queues** excel at **dynamic resource allocation** where you need to track "when will the next resource become available?"

```python
import heapq

def meeting_rooms_heap(intervals):
    if not intervals:
        return 0
    
    # ğŸ”„ Sort meetings by start time
    intervals.sort(key=lambda x: x[0])
    
    # ğŸ”ï¸ Min-heap tracks end times of ongoing meetings
    heap = []
    maxHeapSize = 0
    for start, end in intervals:
        # ğŸƒ Remove meetings that have ended
        while heap and heap[0] <= start:
            heapq.heappop(heap)
        
        # ğŸ¢ Add current meeting's end time
        heapq.heappush(heap, end)
        maxHeapSize = max(maxHeapSize, len(heap))
    
    # ğŸ“Š Heap size = max concurrent meetings
    return len(heap)
```


#### ğŸ“š **Employee Free Time with K-Way Merge**

```python
def employee_free_time_heap(schedule):
    import heapq
    
    # ğŸ”ï¸ Initialize heap with first interval from each employee
    heap = []
    for i, employee in enumerate(schedule):
        if employee:
            heapq.heappush(heap, (employee[0][0], i, 0))
    
    result = []
    prev_end = 0
    
    # ğŸ”„ Process intervals in chronological order
    while heap:
        start, emp_idx, int_idx = heapq.heappop(heap)
        interval = schedule[emp_idx][int_idx]
        
        # ğŸ†“ Gap detected between prev_end and current start
        if prev_end < interval[0]:
            result.append([prev_end, interval[0]])
        
        # ğŸ“ˆ Update running end time
        prev_end = max(prev_end, interval[1])
        
        # ğŸ”„ Add next interval from same employee
        if int_idx + 1 < len(schedule[emp_idx]):
            next_interval = schedule[emp_idx][int_idx + 1]
            heapq.heappush(heap, (next_interval[0], emp_idx, int_idx + 1))
    
    return result
```


#### ğŸ¯ **Heap Visual Example**

```
Input: [[1,3], [2,6], [8,10], [15,18]]

ğŸ”ï¸ Heap State Tracking:
Meeting [1,3] starts: heap = [3]
Meeting [2,6] starts: heap = [3,6]
Meeting [8,10] starts: 8 > 3, pop(3), heap = [6,10]
Meeting [15,18] starts: 15 > 6, pop(6,10), heap = [18]

Max heap size = 2 rooms needed ğŸ¯
```


#### ğŸ’» **Complete Heap Coding Examples**

**ğŸ¯ Example 1: Meeting Rooms II (LC 253)**

```python
import heapq

def minMeetingRooms(intervals):
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap to track end times
    heap = [intervals[0][1]]
    
    for i in range(1, len(intervals)):
        # If earliest meeting has ended, reuse room
        if intervals[i][0] >= heap[0]:
            heapq.heappop(heap)
        
        # Add current meeting's end time
        heapq.heappush(heap, intervals[i][1])
    
    return len(heap)
```

**ğŸ¯ Example 2: Employee Free Time (LC 759)**

```python
import heapq

def employeeFreeTime(schedule):
    # Flatten all intervals and sort
    intervals = []
    for employee in schedule:
        for interval in employee:
            intervals.append(interval)
    
    intervals.sort(key=lambda x: x.start)
    
    # Merge overlapping intervals
    merged = [intervals[0]]
    for current in intervals[1:]:
        if current.start <= merged[-1].end:
            merged[-1].end = max(merged[-1].end, current.end)
        else:
            merged.append(current)
    
    # Find gaps between merged intervals
    result = []
    for i in range(1, len(merged)):
        if merged[i-1].end < merged[i].start:
            result.append(Interval(merged[i-1].end, merged[i].start))
    
    return result
```

**ğŸ¯ Example 3: Car Pooling (LC 1094)**

```python
import heapq

def carPooling(trips, capacity):
    # Sort trips by pickup time
    trips.sort(key=lambda x: x[1])
    
    heap = []  # (dropoff_time, passengers)
    current_passengers = 0
    
    for passengers, pickup, dropoff in trips:
        # Remove passengers who have been dropped off
        while heap and heap[0][0] <= pickup:
            _, dropped = heapq.heappop(heap)
            current_passengers -= dropped
        
        # Add current passengers
        current_passengers += passengers
        if current_passengers > capacity:
            return False
        
        # Schedule dropoff
        heapq.heappush(heap, (dropoff, passengers))
    
    return True
```

**ğŸ¯ Example 4: My Calendar III (LC 732)**

```python
import heapq
from collections import defaultdict

class MyCalendarThree:
    def __init__(self):
        self.events = defaultdict(int)
    
    def book(self, start, end):
        self.events[start] += 1
        self.events[end] -= 1
        
        # Calculate max overlap using sweep line
        active = max_active = 0
        for time in sorted(self.events.keys()):
            active += self.events[time]
            max_active = max(max_active, active)
        
        return max_active
```


#### ğŸ¯ **Priority Queue/Heap Problem Examples**

**1ï¸âƒ£ Meeting Rooms II (LC 253)**

- Find minimum conference rooms needed
- **Key insight**: Use min-heap to track earliest ending meetings, heap size = concurrent rooms

**2ï¸âƒ£ Employee Free Time (LC 759)**

- Find common free time across all employee schedules
- **Key insight**: K-way merge using heap to process intervals chronologically

**3ï¸âƒ£ Car Pooling (LC 1094)**

- Determine if car capacity can handle all trip requests
- **Key insight**: Use heap to track when passengers get off, check capacity at each pickup

**4ï¸âƒ£ My Calendar III (LC 732)**

- Track maximum number of overlapping events
- **Key insight**: Use heap to maintain active events, return max heap size seen

**5ï¸âƒ£ The Skyline Problem (LC 218)**

- Generate skyline from building coordinates
- **Key insight**: Use max-heap to track active building heights at each x-coordinate


## ğŸ“Š **Comprehensive Approach Comparison Table**

| ğŸ¯ **Approach** | â° **Time** | ğŸ’¾ **Space** | ğŸ› ï¸ **Best For** | ğŸ“ **Key Insight** | ğŸª **Template Pattern** |
| :-- | :-- | :-- | :-- | :-- | :-- |
| **ğŸ”„ Standard Merge** | O(n log n) | O(1) | Basic interval merging | Sort + iterate, extend end times | `sort() â†’ check overlap â†’ merge` |
| **ğŸ”„ Sweep Line** | O(n log n) | O(n) | Event-based problems, gaps | Convert to events, track state changes | `events[] â†’ sort() â†’ sweep` |
| **ğŸ‘† Two-Pointer** | O(m + n) | O(1) | Two sorted lists, intersections | Parallel traversal of sorted arrays | `i=0, j=0 â†’ compare â†’ advance` |
| **ğŸ”ï¸ Min-Heap** | O(n log k) | O(k) | Resource allocation, k-way merge | Track earliest available resources | `sort() â†’ heap â†’ push/pop` |
| **ğŸ”ï¸ Max-Heap** | O(n log n) | O(n) | Skyline, height tracking | Maintain maximum active values | `events[] â†’ max_heap â†’ track_max` |

### ğŸ¯ **Problem-to-Approach Mapping**

| **Problem Type** | **ğŸ¥‡ Primary** | **ğŸ¥ˆ Secondary** | **ğŸ¥‰ Alternative** | **Example Problems** |
| :-- | :-- | :-- | :-- | :-- |
| **ğŸ“ Basic Merge** | Standard Merge | - | - | LC 56: Merge Intervals |
| **ğŸ”„ Insert/Update** | 3-Phase | Standard Merge | - | LC 57: Insert Interval |
| **ğŸ¢ Room Allocation** | Min-Heap | Two-Pointer | Sweep Line | LC 253: Meeting Rooms II |
| **ğŸ” Intersections** | Two-Pointer | - | Standard Merge | LC 986: Interval Intersections |
| **ğŸ†“ Find Gaps** | Standard Merge | Sweep Line | K-Way Merge | LC 759: Employee Free Time |
| **ğŸ“Š Event Counting** | Sweep Line | Heap | - | LC 1094: Car Pooling |
| **ğŸ—ï¸ Skyline/Heights** | Max-Heap + Sweep | - | - | LC 218: Skyline Problem |
| **ğŸ“… Calendar Systems** | Sweep Line | Heap | - | LC 731/732: My Calendar |

### ğŸš€ **Performance Characteristics**

| **Data Size** | **ğŸ”„ Standard** | **ğŸ”„ Sweep Line** | **ğŸ‘† Two-Pointer** | **ğŸ”ï¸ Heap** |
| :-- | :-- | :-- | :-- | :-- |
| **Small (n â‰¤ 100)** | âœ… Perfect | âœ… Perfect | âœ… Perfect | âœ… Perfect |
| **Medium (n â‰¤ 10Â³)** | âœ… Excellent | âœ… Excellent | âœ… Excellent | âœ… Excellent |
| **Large (n â‰¤ 10âµ)** | âœ… Good | âœ… Good | âœ… Excellent | âœ… Good |
| **Very Large (n â‰¤ 10â¶)** | âš ï¸ Acceptable | âš ï¸ Acceptable | âœ… Excellent | âš ï¸ Depends on k |

### ğŸ’¡ **Complexity Deep Dive**

| **Approach** | **Sort Cost** | **Process Cost** | **Space Usage** | **When k << n** |
| :-- | :-- | :-- | :-- | :-- |
| **Standard Merge** | O(n log n) | O(n) | O(1) extra | Same |
| **Sweep Line** | O(n log n) | O(n) | O(n) events | Same |
| **Two-Pointer** | O(n log n) | O(n) | O(n) arrays | Same |
| **Min-Heap** | O(n log n) | O(n log k) | O(k) heap | **ğŸš€ Better!** |
| **K-Way Merge** | O(0) | O(n log k) | O(k) heap | **ğŸš€ Much Better!** |

### ğŸ¯ **Selection Decision Tree**

```
ğŸ“‹ Problem Analysis:
â”‚
â”œâ”€ ğŸ” Single list merging?
â”‚   â””â”€ âœ… Use Standard Merge
â”‚
â”œâ”€ ğŸ‘¥ Two sorted lists?
â”‚   â””â”€ âœ… Use Two-Pointer
â”‚
â”œâ”€ ğŸ“Š Counting events/overlaps?
â”‚   â””â”€ âœ… Use Sweep Line
â”‚
â”œâ”€ ğŸ¢ Resource allocation?
â”‚   â””â”€ âœ… Use Min-Heap
â”‚
â”œâ”€ ğŸ—ï¸ Height/skyline tracking?
â”‚   â””â”€ âœ… Use Max-Heap + Sweep
â”‚
â””â”€ ğŸ‘¥ K sorted lists (k << n)?
    â””â”€ âœ… Use K-Way Merge (Heap)
```


## ğŸš¨ **Common Pitfalls: Meeting Rooms II Analysis**

### âŒ **Why This Code is WRONG**

```python
# ğŸš¨ INCORRECT SOLUTION - DO NOT USE
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        maxOverlaps, numOverlaps = 0, 0
        intervals.sort(key = lambda i: i[0])

        prevStart, prevEnd = 0, 0
        for interval in intervals:
            start, end = interval
            # [a,b] and [c,d] overlap iff a<=d and c<=b
            isOverlapping = prevStart <= end and start <= prevEnd
            if isOverlapping:
                numOverlaps += 1
                prevStart, prevEnd = max(prevStart, start), min(prevEnd, end)
            else : 
                numOverlaps = 0  # ğŸš¨ FATAL BUG HERE
                prevStart, prevEnd = start, end
            maxOverlaps = max(maxOverlaps, numOverlaps)
        return 1 if maxOverlaps == 0 else maxOverlaps
```


### ğŸ” **Critical Bugs Breakdown**

#### **ğŸš¨ Bug 1: Fundamental Misunderstanding**

The code tracks `numOverlaps` as **consecutive overlapping intervals** rather than **simultaneous meetings**. The line `numOverlaps = 0` when no immediate overlap is found **loses track of rooms still occupied** by earlier meetings.

#### **ğŸš¨ Bug 2: Wrong Overlap Detection**

The algorithm only checks if the current interval overlaps with the **immediately previous interval**:

```python
isOverlapping = prevStart <= end and start <= prevEnd
```

This pairwise comparison **cannot detect multiple simultaneous meetings**. It misses the fact that meeting `` is still running when `[1][2]` starts.

#### **ğŸš¨ Bug 3: Incorrect Merge Logic**

When overlap is detected, the code executes:

```python
prevStart, prevEnd = max(prevStart, start), min(prevEnd, end)
```

This creates the **intersection** of intervals, not the union. For intervals ``and `[3][4]`, it produces `[3][4]` instead of maintaining the coverage of``. This **destroys information** about the actual time span covered.

#### **ğŸš¨ Bug 4: Resetting Counter Prematurely**

The reset `numOverlaps = 0` when no immediate overlap is found **forgets about ongoing meetings**. This is why the algorithm returns `1` instead of `2` for the standard test case.

### ğŸ“Š **Execution Trace Example**

For `intervals = [, [3][4], [1][2]]`:

```
ğŸ¯ EXPECTED OUTPUT: 2 rooms needed

âŒ BUGGY ALGORITHM TRACE:
Step | Current Interval | Overlap Check | Action | numOverlaps | Result |
-----|------------------|---------------|--------|-------------|---------|
1    | [0,30]          | âœ“ (with [0,0]) | Increment | 1 | prev = [0,30] âŒ |
2    | [5,10]          | âœ— (5 > 0 but 5 â‰¤ 0 false) | Reset | 0 | prev = [5,10] |
3    | [15,20]         | âœ— (15 > 10) | Reset | 0 | prev = [15,20] |

Final result: 1 âŒ (Expected: 2)
```


### âœ… **Correct Solutions Comparison**

| Approach | Key Insight | Visual Representation |
| :-- | :-- | :-- |
| **Two-Pointer** | Separate start/end events | `Starts: [3][1] Ends: [4][2]` |
| **Heap** | Track earliest ending meetings | `heap= â†’ heap=[4] â†’ heap=[2]` |
| **Sweep Line** | Process all events chronologically | `Events: [(0,+1), (5,+1), (10,-1), (15,+1), (20,-1), (30,-1)]` |

### ğŸ§  **Key Takeaway for Interviews**

The provided code fails because it **treats interval merging as a pairwise sequential process** rather than understanding that Meeting Rooms II requires tracking **all simultaneous activities across the entire timeline**. The problem demands algorithms that can handle **multiple concurrent events**, not just adjacent interval relationships.

**ğŸ¯ Remember**: Meeting Rooms II is about **concurrency**, not **merging**!

## ğŸ’¡ Interview Success Tips

### ğŸ¯ **Problem Recognition Signals**

- Keywords: "merge", "overlap", "intersect", "schedule", "meeting"
- Data: Time intervals, ranges, schedules
- Goals: Consolidate, find gaps, count conflicts


### âš¡ **Optimization Strategies**

| Scenario | Best Approach | Time Complexity |
| :-- | :-- | :-- |
| ğŸ“ Simple merge | Sort + iterate | O(n log n) |
| ğŸ”„ Two lists | Two-pointer | O(m + n) |
| ğŸ“Š Dynamic events | Sweep line | O(n log n) |
| ğŸ¢ Resource allocation | Heap | O(n log n) |

### ğŸš¨ **Common Edge Cases**

```python
# ğŸ” Always check for:
intervals = []                    # Empty input
intervals = [[1,1]]              # Single point
intervals = [[1,2], [2,3]]       # Touching intervals
intervals = [[1,4], [2,3]]       # Complete containment
```


### ğŸ›¡ï¸ **Debug Checklist**

- âœ… Sorted input correctly?
- âœ… Handled touching intervals?
- âœ… Updated end time with `max()`?
- âœ… Covered all three merge phases?
- âœ… Distinguished between merging vs. counting concurrent intervals?


## ğŸª **ASCII Problem Solving Flow**

```
ğŸ¯ STEP-BY-STEP PROCESS:

Input: [[6,8], [1,3], [2,4], [15,18]]
       ğŸ“…    ğŸ“…     ğŸ“…      ğŸ“…

1ï¸âƒ£ SORT: [[1,3], [2,4], [6,8], [15,18]]
         ğŸ“…    ğŸ“…    ğŸ“…     ğŸ“…

2ï¸âƒ£ MERGE:
   [1,3] + [2,4] â†’ [1,4] âœ… (overlap: 2 â‰¤ 3)
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   
   [1,4] + [6,8] â†’ No overlap âŒ (6 > 4)
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   
   [6,8] + [15,18] â†’ No overlap âŒ (15 > 8)
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

3ï¸âƒ£ RESULT: [[1,4], [6,8], [15,18]]
           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
```


## ğŸ† **Master Problem Set**

| Problem | Difficulty | Key Technique |
| :-- | :-- | :-- |
| ğŸŸ¢ Merge Intervals | Easy | Basic template |
| ğŸŸ¡ Insert Interval | Medium | 3-phase approach |
| ğŸŸ¡ Meeting Rooms II | Medium | Heap/Two-pointer |
| ğŸ”´ Employee Free Time | Hard | K-way merge |
| ğŸŸ¡ Interval Intersections | Medium | Two-pointer |

## ğŸ§  **Memory Aids**

**ğŸµ "SORT-CHECK-MERGE" Mantra:**

- **S**ort intervals by start time
- **C**heck for overlap condition
- **M**erge by taking max end time

**ğŸ”— Overlap Formula:** `startâ‚ â‰¤ endâ‚‚ AND startâ‚‚ â‰¤ endâ‚`

**ğŸš¨ Meeting Rooms Reminder:** "Concurrency â‰  Merging" - track simultaneous events, don't merge them!

This pattern appears in **15-20%** of interval-related interview questions, making it a high-impact skill for technical interviews! ğŸš€

[1]: https://www.perplexity.ai/search/b041e9dd-6359-4815-a388-936397f22558

[2]: https://www.perplexity.ai/search/8c487135-2907-42fa-af08-d887da753ffb

[3]: https://www.perplexity.ai/search/b1b73da3-76a7-491c-8bde-145789d9c38f

[4]: https://www.perplexity.ai/search/e5f9e1a8-1c4b-445f-aa28-b21881892da5